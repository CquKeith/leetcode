# 装饰器模式

## Intent

为对象动态的添加功能。就增加功能来说，装饰器模式相比生成子类更为灵活。

## Class Diagram

![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png)

装饰者（Decorator）和具体组件（ConcreteComponent）都实现了组件（Component）接口，具体组件的方法不需要依赖于其他对象。而装饰者组合了一个组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而保留了被装饰者的功能。可以看到，具体组件应该是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖其他对象。

## 关键代码

- Component类充当抽象角色，不应该具体实现
- 修饰类引用和继承Component类，具体扩展类重写父类方法

## 优点

- 装饰类和被装饰类可以独立发展，不会相互耦合，装饰器模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能

## 缺点

- 多层装饰比较复杂

## 使用场景

- 扩展一个类的功能
- 动态增加功能，动态撤销

## 1. 饮料

设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。

下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。

![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg)

### 设计原则

类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。

饮料可以动体啊添加新的配料，而不需要去修改饮料的代码。

不可能把所有的类设计成 都满足这一原则，应当把该原则应用于左右可能发生改变的地方。

## 2. LOL 英雄学习技能

装饰者模式为已有类动态附加额外的功能，比如英雄升级。每次英雄升级都会附加一个新的额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是Decorator，每个技能就是ConcreteDecorator。

## 3. 绝地求生 枪

 Kar 98K有5发子弹；
 装上弹匣后有10发子弹；
 装上4倍镜后可以进行4倍瞄准；
 装上8倍镜后可以进行4倍瞄准、8倍瞄准。