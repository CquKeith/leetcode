# 解释器模式

# Intent

为语言创建解释器，通常由语言的语法和语法分析来定义。

定义一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标示来解释语言中的句子。

## Class Diagram

TerminalExpression：终结符表达式，每个终结符都需要一个TerminalExpression

Context：上下文，包含解释器之外的一些全局信息

![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/2b125bcd-1b36-43be-9b78-d90b076be549.png)

## 何时使用

如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言汇总的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

# 优点

1. 可扩展性好，灵活
2. 增加了新的解释表达式
3. 易于实现简单文法

## 缺点

1. 可利用场景比较少
2. 对于复杂的文法比较难维护
3. 解释器模式会引起类膨胀（也即是，类中成员过多，甚至出现无序增加的情况。多大的类，会使复杂度急剧增加，维护会变得很困难）
4. 解释器模式采用递归调用方式



## 1. 规则校验器

以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。

例如一颗解析树为 **D And (A Or (B C))**，文本 "D A" 满足该解析树定义的规则。
这里的 Context 指的是 String。

